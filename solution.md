# Solution: Comprehensive Formatting Layer

## 1. First-Principles Analysis

The current pipeline operates on a fragile "text-to-implicit-structure" assumption:
1.  **Input**: Raw images.
2.  **Processing**: LLM outputs Markdown text.
3.  **Rendering**: Typst + `cmarker` tries to interpret that Markdown.

### The Core Problem
The LLM is tasked with two distinct responsibilities simultaneously:
1.  **Semantic Understanding**: Identifying theorems, proofs, equations, and structure.
2.  **Syntactic Formatting**: Correctly placing `:::theorem`, `$$`, and escaping characters for the specific `mitex` subset supported by Typst.

This fails because LLMs are non-deterministic. A single missing newline, a misplaced bracket, or using `\text{}` instead of `\mathrm{}` causes the rendering engine to crash or produce ugly output. The downstream renderer (`typst`) expects perfect syntax, but the upstream generator (`gemini`) provides probabilistic text.

### The Solution: A Validated Intermediate Representation (IR)
We must decouple **understanding** from **formatting**.
1.  **Gemini** should output **Strict JSON** (Semantic Data). It shouldn't worry about `:::` syntax.
2.  **Formatting Layer** (TypeScript) validates this JSON against a rigid schema.
3.  **Renderer Adapter** (TypeScript) programmatically converts the valid JSON into perfect Typst-compatible Markdown.

This ensures that **syntax errors are mathematically impossible** in the final output, because the syntax is generated by deterministic code, not the LLM.

---

## 2. Proposed System Architecture

### 2.1 Schema Definition (The "Contract")
We will use `zod` to define the strict shape of the document. This runs on Vercel's lightweight serverless functions with near-zero latency.

```typescript
import { z } from 'zod';

// Basic building blocks
const LatexString = z.string().describe("Valid LaTeX math string, e.g., 'E = mc^2'");

const ContentBlock = z.discriminatedUnion("type", [
  z.object({ type: z.literal("paragraph"), text: z.string() }),
  z.object({ type: z.literal("heading"), level: z.number().min(1).max(3), text: z.string() }),
  z.object({ type: z.literal("math"), latex: LatexString, display: z.boolean() }),
  z.object({ type: z.literal("list"), items: z.array(z.string()), ordered: z.boolean() }),
  
  // Semantic blocks (Theorems, Proofs, etc.)
  z.object({ 
    type: z.literal("container"), 
    kind: z.enum(["theorem", "proof", "definition", "example", "note", "warning"]),
    title: z.string().optional(),
    content: z.string().describe("Markdown content inside the block")
  }),
]);

export const DocumentSchema = z.object({
  metadata: z.object({
    title: z.string(),
    subject: z.string(),
    documentType: z.enum(["lecture", "problem-set", "summary"]),
  }),
  content: z.array(ContentBlock),
});

export type DocumentIR = z.infer<typeof DocumentSchema>;
```

### 2.2 The Formatting Layer (Logic)

This layer sits in `lib/formatting.ts` and acts as the bridge.

#### Step A: Validation & Sanitization
Before rendering, we pass the JSON through a sanitizer that fixes common LLM mistakes *within* the strings.

```typescript
function sanitizeLatex(latex: string): string {
  return latex
    .replace(/\\text\{([^}]+)\}/g, (match, content) => `\\mathrm{${content}}`) // Fix \text issue
    .replace(/\\([a-zA-Z]+)/g, (match, cmd) => {
      // Check against allowlist, maybe replace forbids
      return ALLOWED_COMMANDS.includes(cmd) ? match : match; 
    });
}
```

#### Step B: Deterministic Generation
We write a pure function `renderToMarkdown(ir: DocumentIR): string` used by `typst.ts`.

```typescript
export function renderToMarkdown(ir: DocumentIR): string {
  let md = `# ${ir.metadata.title}\n\n`;
  
  for (const block of ir.content) {
    switch (block.type) {
      case "heading":
        md += `${"#".repeat(block.level)} ${block.text}\n\n`;
        break;
        
      case "math":
        // Programmatically ensure $$ wrapping for display math
        const math = sanitizeLatex(block.latex);
        md += block.display ? `$$\n${math}\n$$\n\n` : `$${math}$`;
        break;
        
      case "container":
        // Programmatically generate the ::: syntax
        // strict syntax: :::kind[title]{attributes}
        const titleProp = block.title ? `[${block.title}]` : "";
        md += `:::${block.kind}${titleProp}\n${block.content}\n:::\n\n`;
        break;
        
      // ... handle other cases
    }
  }
  
  return md;
}
```

## 3. Implementation Plan

### Phase 1: Create the Schema and Generator (Low Risk)
1.  **New File**: `lib/schema.ts` containing the Zod definitions.
2.  **New File**: `lib/formatting.ts` containing `renderToMarkdown` and `sanitizeLatex`.
3.  **Test**: Write a unit test `tests/formatting.test.ts` that takes a mock JSON object and asserts it produces perfect Markdown output.

### Phase 2: Update Gemini Prompt (High Impact)
1.  **Modify `lib/gemini.ts`**:
    -   Update `SYSTEM_PROMPT` to remove the manual formatting instructions (e.g., "Use :::theorem").
    -   Instead, instruct it to "Output JSON adhering to this schema: ..." (or use Gemini Pro 1.5's native `responseSchema` mode if available/enabled, otherwise strict JSON prompting).
2.  **Switch Mode**: Change the API call in `app/api/process-batch` to parse the response as JSON using `JSON.parse()` (wrapped in a try-catch with a "repair" step if needed).

### Phase 3: Connect to Typst
1.  **Modify `lib/typst.ts`**:
    -   It currently accepts a raw string. We can keep this signature.
    -   The caller (`app/api/process-batch`) will now do: `Gemini -> JSON -> FormattingLayer -> Markdown String -> Typst`.

## 4. Verification

1.  **Unit Tests**: Verify that `renderToMarkdown` handles edge cases (empty blocks, special characters in titles).
2.  **Integration Test**: Run the full pipeline with a sample image.
3.  **Format Check**: Inspect the generated `content.md` in the temp folder to ensure it strictly follows the `cmarker` syntax requirements.

## 5. Why this meets all constraints
-   **Vercel Free Tier**: Zod and string manipulation are negligible in CPU/Memory.
-   **No Architectural Change**: We are just refining the data passed between existing components (`Gemini` -> `Typst`).
-   **Latency**: JSON is faster to generate for LLMs than verbose Markdown with complex syntax rules, as they don't have to "think" about the syntax, just the data structure.
